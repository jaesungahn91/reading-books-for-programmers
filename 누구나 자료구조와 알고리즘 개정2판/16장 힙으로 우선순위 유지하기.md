- 힙은 데이터 세트에서 가장 큰 또는 가장 작은 데이터 원소를 계속 알아내야 할 때 특히 유용

## 16.1 우선순위 큐
- 우선순위 큐는 큐 앞에서만 데이터에 접근하고 삭제하되 데이터를 삽입할 때는 데이터를 늘 특정 순서대로 정렬시킨다.
- 배열 기반 우선순위 큐는 삭제가 O(1), 삽입이 O(N)이다.

## 16.2 힙
- 이진 힙은 특수한 종류의 이진 트리다. 이진 트리는 각 노드에 최대 자식 노드가 둘인 트리
- 이진 힙에도 최대 힙과 최소 힙 두 종류
- 힙은 다음의 조건을 따르는 이진 트리
	- 각 노드의 값은 그 노드의 모든 자손 노드의 값보다 커야 한다. 이 규칙을 힙 조건이라고 한다.
	- 트리는 완전해야 한다.

### 16.2.1 힙 조건
- 힙 조건이란 각 노드의 값이 그 노드의 모든 자손 노드보다 커야 한다
- 최소 힙은 노드가 자손보다 작은 값을 갖도로 힙을 구성

### 16.2.2 완전 트리
- 완전 트리는 빠진 노드 없이 노드가 완전히 채워진 트리
- 바닥 줄에는 빈 자리가 있을 수 있다. 단 빈 자리의 오른쪽으로 어떤 노드도 없어야 한다.

## 16.3 힙 속성
- 힙은 이진 탐색 트리에 비해 약한 정렬
- 힙에는 자손이 조상보다 클 수 없다는 분명한 순서가 있지만 값을 검색하기에는 부족
- 힙에서는 루트 노드가 항상 최댓값이라는 점
- 힙의 주요 연산은 삽입과 삭제
- 힙에는 마지막 노드가 있다. 힙의 마지막 노드는 바닥 레벨에서 가장 오른쪽에 있는 노드.

## 16.4 힙 삽입
- 힙에 새 값을 삽입하려면 다음 알고리즘을 수행
	- 바닥 레벨의 가장 오른쪽 노드 옆에 새로운 노드 삽입 = 힙의 마지막 노드
	- 이어서 새로 삽입한 노드와 그 부모 노드를 비교
	- 새 노드가 부모 노드보다 크면 새 노드와 부모 노드를 스왑
	- 새 노드보다 큰 부모 노드를 만날 때까지 3단계를 반복하며 새 노드를 힙 위로 올린다.
- 새 노드를 힙 위로 올리는 과정을 노드를 위로 트리클링
- 힙 삽입의 효율성은 O(logN)

## 16.5 마지막 노드 탐색
- 새 값을 넣을 자리를 탐색해야하는 문제를 마지막 노드 문제라 부른다.

## 16.6 힙 삭제
- 힙의 루트 노드를 삭제하는 알고리즘
	- 마지막 노드를 루트 노드자리로 옮긴다.
	- 루트 노드를 적절한 자리까지 아래로 트리클링한다.
		- 트리클 노드의 두 자식을 확인해 어느 쪽이 더 큰지 본다.
		- 트리클 노드가 두 자식 노드 중 큰 노드보다 작으면 큰 노드와 트리클 노드를 스왑
		- 트리클 노드에 그 노드보다 큰 자식이 없을 때까지 1, 2단계를 반복
- 힙에서 삭제 시간 복잡도 O(logN)

## 16.7 힙 대 정렬된 배열
- 정렬된 배열
	- 삽입 : O(N)
	- 삭제 : O(1)
- 힙
	- 삽입 : O(logN)
	- 삭제 : O(logN)

## 16.8 다시 살펴보는 마지막 노드 문제
- 균형이 중요한 이유는 O(logN) 안에 연산이 가능하기 때문

## 16.9 배열로 힙 구현하기
- 힙을 배열로 구현하는 이유는 마지막 노드 문제를 해결하기 위해
- 배열로 힙을 구현하면 마지막 노드는 항상 배열의 마지막 원소

### 16.9.1 배열 기반 힙 순회
- 어떤 노드의 왼쪽 자식을 찾으려면 (index * 2) + 1
- 어떤 노드의 오른쪽 자식을 찾으려면 (index * 2) + 2
- 어떤 노드의 부모를 찾으려면 (index - 1) / 2

## 16.10 우선순위 큐로 쓰이는 힙
- 힙의 약한 정렬이 굉장한 장점으로 작용
- 완벽히 정렬할 필요가 없으니 새 값을 O(logN) 시간에 삽입할 수 있다.
- 최댓값에 항상 접근할 수 있을만큼 정렬