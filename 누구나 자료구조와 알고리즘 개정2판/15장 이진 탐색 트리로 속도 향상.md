- 데이터를 자주 정렬해야 하면 다시 정렬하는 일이 없게 애초에 데이터를 항상 정렬된 순서로 유지하는 편이 합리적
- 정렬된 배열은 삽입과 삭제가 상대적으로 느림
## 15.1 트리
- 노드 기반 자료 구조
- 트리의 각 노드는 여러 노드로의 링크를 포함할 수 있다.
- 루트 : 가장 상위 노드, 트리의 꼭대기
- 부모와 자식, 자손과 조상
- 트리에는 레벨이 있다. 각 레벨은 트리에서 같은 줄
- 트리의 프로퍼티는 균형 잡힌 정도를 말한다. 모든 노드에서 하위 트리의 노드 개수가 같으면 그 트리는 균형트리다.
- 균형이 맞지 않는 트리는 불균형 트리

## 15.2 이진 탐색 트리
- 이진 트리는 각 노드에 자식이 0개나 1개, 2개다.
- 이진 탐색 트리는 다음의 규칙이 추가된 트리다.
	- 각 노드의 자식은 최대 왼쪽에 하나, 오른쪽에 하나다.
	- 한 노드의 왼쪽 자손은 그 노드보다 작은 값만 포함할 수 있다. 마찬가지로 오른쪽 자손은 그 노드보다 큰 값만 포함할 수 있다.

## 15.3 검색
### 15.3.1 이진 탐색 트리 검색의 효율성
- 이진 탐색 트리 검색은 각 단계마다 남은 값 중 반을 제거하는 모든 알고리즘을 나타내는 O(longN)이다. (최선의 시나리오인 포화 균형 이진 탐색 트리에서만)

### 15.3.2 log(N) 레벨
- 이진 트리에 노드가 N개면 레벨(즉, 줄)이 약 logN개라는 이진 트리의 또 다른 일반적 속성이 밝혀진다.
- 노트가 N개인 트리에서 모든 자리마다 노드를 두려면 log(N) 레벨이 필요하다.
- 노드가 N개인 균형 트리의 레벨은 log(N)이라 할 수 있다.
- 이진 탐색 트리 검색은 정렬된 배열의 이진검색과 효율성이 같다.

## 15.4 삽입
- 삽입은 (logN) + 1단계 걸리며 빅 오는 상두를 무시하므로 O(logN)
- 정렬된 배열에서는 검색뿐 아니라 값을 삽입할 공간을 마련하기 위해 많은 데이터를 오른쪽으로 시프트해야 하기 때문에 삽입에 O(N)이 걸린다.

### 15.4.2 삽입 순서
- 무작위로 정렬된 데이터로 트리를 생성해야 대게 균형 잡힌 트리가 생성된다.
- 반대로 정렬된 데이터를 트리에 삽입하면 불균형이 심하고 덜 효율적일 수 있다.
- 오로지 균형 트리일 때만 검색에 O(logN)
- 불균형이 심한 트리 검색은 O(N)
- 최선의 시나리오인 완전히 균형 잡힌 트리 검색은 O(logN)

## 15.5 삭제
### 15.5.1 자식이 둘인 노드 삭제
- 자식이 둘인 노드를 삭제할 때는 삭제된 노드를 후속자 노드로 대체한다. 후속자 노드란 삭제된 노드보다 큰 값 중 최솟값을 갖는 자식 노드

### 15.5.2 후속자 노드 찾기
- 삭제된 값의 오른쪽 자식을 방문해서 그 자식의 왼쪽 자식을 따라 계속해서 방문하며 더 이상 ㄱ왼쪽 자식이 없을 때까지 내려간다. 바닥값이 후속자 노드다.

### 15.5.3 오른쪽 자식이 있는 후속자 노드
- 후속자 노드에 오른쪽 자식이 있으면 후속자 노드를 삭제된 노드가 있던 자리에 넣은 후, 후속자 노드의 오른쪽 자식을 후속자 노드의 원래 부모의 왼쪽 자식으로 넣는다.

### 15.5.6 이진 탐색 트리 삭제의 효율성
- 검색과 삽입처럼 트리 삭제도 일반적으로 O(logN)