## 수정 공포와 변경 비용
- 레거시 코드는 단순히 예전 방식으로 만들어진 코드만을 지칭하는 것이 아니다.
- 레거시에 대한 정의가 무엇이든 간에 수정하기 어렵다는 공통점이 있다.
- 레거시에서 나타나는 흔한 특성
	- 긴 클래스, 긴 메서드
	- 복잡한 코드
	- 이상한 이름
	- 많은 중복
	- 테스트 코드 없음
- 이런 특징은 코드 수정으 어렵게 만든다.
- 레거시 코드 수정과 악순환
```
레거시 코드 이해하는 데 많은 노력 필요 => 이해 부족 상태에서 코드 수정해야 함 => 변경에 대한 두려움 => 코드 덧대기로 두려움 회피 => 반복
```
- 악순환은 개발 비용 증가
- 내가 만든 코드지만 수정하기 두렵다면 그게 바로 레거시다.
- 레거시는 폄하 대상이 아니다. "개선할 거리가 있다" 라고 생각하자

## 리팩터링
- 코드 수정 비용을 낮추려면 결국 코드를 수정하기 쉬운 구조로 바꿔야 한다. 그 방법 중 하나가 리팩터링이다.
- 리팩터링은 외부로 드러나는 동작이나 기능을 변경하지 않고 내부 구조를 변경해서 재구성하는 기법이다.
- 코드 가독성이 높아지고 리팩터링 이전보다 구현 변경과 확장이 용이해진다. 이러한 변화는 단기적으로는 수정 비용을 낮춰주고 장기적으로는 개발 비용을 줄여준다.

### 미사용 코드 삭제
- 가장 쉽지만 가장 부담되는 리팩터링이 코드 삭제
- 메서드와 클래스를 삭제할 때는 리플렉션으로 접근하는 코드인지 확인해 봐야 한다.

### 매직 넘버
- 값을 갖는 수자를 매직 넘버라고 표현한다.
- 매직 넘버는 그 값이 무엇을 의미하는지 유추하기 어렵다.

### 이름 변경
- 이름과 실제 의미가 일치하지 않으면 코드를 분석할 때 혼란을 격게 된다.
- 의미가 잘 들어나지 않는 이름을 만나면 좀 더 알맞은 이름으로 변경

### 메서드 추출
- 메서드를 추출하기 좋은 대상은 if-else의 각 블록에 있는 코드
- 무턱대고 메서드를 추출하면 안된다. 가독성이나 응집도가 좋아지는 방향으로 메서드를 추출해야 한다.

### 클래스 추출
- 로직을 구현한 코드가 길고 로컬변수를 사용하여 복잡한 경우 메서드 추출 대신 클래스 추출을 고려해 볼 수 있다.

### 클래스 분리
- 한 클래스에 많은 기능이 모여 있으면 각 기능을 별도 클래스로 분리한다.

### 메서드 분리
- 메서드가 완전히 구분되는 기능을 구현하고 있는 경우에는 각 기능을 구현하는 메서드를 따로 만들고 분리해서 기능별로 응집도를 높여야 한다.

### 파라미터값 정리
- 메서드에서 사용하지 않는 파라미터 데이터는 제거

### for에서 하는 2가지 일 분리
- 하나의 for 문에서 여러 가지 작업을 실행하면 서로 다른 목적을 가진 코드가 뒤섞일 수 있다.
- 논리적 단위로 분리하자
	- 코드가 복잡해지지 않고 논리적인 단위로 구분
	- 논리적인 단위로 구분되어 코드를 이해하기가 쉽다.
	- 메서드 추출과 같은 리팩터링이 용이하다.
	- 다른 로직을 추가하기가 용이하다.

## 리팩터링 vs 새로 만들기
- 코드 품질을 개선하는 방법이 리팩터링만 있는 것은 아니고, 새로 만드는 방법도 있다.
- 하지만 새로 만든다고 코드가 좋아진다는 법은 없다. 좋은 코드를 만드는 방법을 알아야 코드 품질이 좋아진다.

