## 아이템 1 : 생성자 대신 정적 팩터리 메서드를 고려하라
- 정적 팩터리 메서드는 디자인 패턴에서의 팩터리 메서드와 다르다.
- 장점
	- 이름을 가질 수 있다.
	- 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
	- 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
	- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반활할 수 있다.
	- 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
- 단점
	- 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
	- 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

## 아이템 2 : 생성자에 매개변수가 많다면 빌더를 고려하라
- 정적팩터리 메소드와 생성자는 선택적 매개변수가 많을 때 적절히 대응하기 어렵다.
- 점층적 생성자 패턴도 쓸 수는 있지만, 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
- 자바빈즈 패턴 : 매개변수가 없는 생성자로 객체를 만든 후, 세터 메서드들을 호출해 원하는 매개변수의 값을 설정하는 방식
- 자바빈즈 패턴에서는 객체 하나를 만들려면 메서드를 여러 개 호출해야 하고, 객체가 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓이게 된다.
- 일관성이 무너지는 문제 때문에 자자빈즈 패턴에서는 클래스를 불변으로 만들 수 없다.
- 벌더 패턴은 명명된 선택적 매개변수를 흉내 낸 것
- 단점으로는 객체를 만들기 위해 빌더 부터 만들어야한다.

## 아이템 3 : private 생성자나 열거 타입으로 싱글턴임을 보증하라
- 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기 어렵다.
- public static final 필드 방식의 싱글턴
- 정적 팩터리 방식의 싱글턴
	- API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다
	- 제네릭 싱글턴 팩터리로 만들 수 있다
	- 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있다
- 원소가 하나인 열거 타입 방식의 싱글턴
	- 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법

## 아이템 4 : 인스턴스화를 막으려거든 private 생성자를 사용하라
- 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한게 아니다. 하지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어준다.
- private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.
	- 이 방식은 상속을 부가능하게 하는 효과도 있다.
- 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.

## 아이템 5 : 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
- 의존 객체 주입 패턴 : 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식

## 아이템 6 : 불필요한 객체 생성을 피하라
- 똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다.
- 생성 비용이 아주 비싼 객체도 더러 있다. 이런 '비싼 객체'가 반복해서 필요하다면 캐싱하여 재사용하길 권한다.
- 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다.
- 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.
- 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일

## 아이템 7 : 다쓴 객체 참조를 해제하라
- 자바처럼 가비지 컬렉터를 갖춘 언어라해서 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해하면 안된다.
- 가비지 컬렌셕 언어에서는 의도치 않게 객체를 살려두는 메모리 누수를 찾기가 아주 까다롭다.
- 다 쓴 참조 : 문자 그대로 다시 쓰지 않을 참조라는 뜻
- 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
- 다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것
- 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다.
- 캐시 역시 메모리 누수를 일으키는 주범
	- WeakHashMap 사용
	- 쓰지 않는 엔트리 이따금 청소

## 아이템 8 : finalizer와 cleaner 사용을 피하라
- 자바는 두 가지 객체 소멸자를 제공
- finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요
- cleaner는 finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요
- 즉, finalizer와 cleaner로는 제때 실행되어야 하는 작업은 절대 할 수 없다.
- 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안 된다.
- finalizer와 cleaner는 심각한 성능 문제도 동반
- finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.
- finalizer나 cleaner를 대신해줄 묘안은 AutoCloseable를 구현하고, 인스턴스를 다 쓰고 나면 close 메소드를 호출하는 것
- 예외가 발생해도 제대로 종료되도록 try-with-resources를 사용

## 아이템 9 : try-finally 보다는 try-with-resources를 사용하라
- try-finally 에서 예외는 try 블록과 finally 블록 모두에서 발생할 수 있어 디버깅을 몹시 어렵게 한다.
- try-with-resources 구조를 사용하려면 해당 자원이 AutoCloseable 인터페이스를 구현해야 한다.
- try-with-resources 이 짧고 읽기 수월할 뿐 아니라 문제를 진단하기도 훨씬 좋다.
