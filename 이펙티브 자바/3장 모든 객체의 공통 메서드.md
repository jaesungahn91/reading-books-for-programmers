## 아이템 10 : equals는 일반 규약을 지켜 재정의하라
- 다음에서 열거한 상황 중 하나에 해당한다면 재정의하지 않는 것이 최선
	- 각 인스턴스가 본질적으로 고유하다.
	- 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
	- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
	- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
- equals를 재정의 해야할 때.
	- 객체 식별성(두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때. 즉, 값이 같은지 알고 싶을 때
- equals 메서드 일반 규약
	- 반사성
	- 대칭성
	- 추이성
	- 일관성
	- null-아님
- equals를 재저의할 땐 hashCode도 반드시 재정의
- 너무 복잡하게 해결하려 들지 말자.
- Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.

## 아이템 11 : equals를 재정의하려거든 hashCode도 재정의하라
- equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.
- 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.
- 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다.

## 아이템 12 : toString을 항상 재정의하라
- 