## 아이템 10 : equals는 일반 규약을 지켜 재정의하라
- 다음에서 열거한 상황 중 하나에 해당한다면 재정의하지 않는 것이 최선
	- 각 인스턴스가 본질적으로 고유하다.
	- 인스턴스의 '논리적 동치성'을 검사할 일이 없다.
	- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
	- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
- equals를 재정의 해야할 때.
	- 객체 식별성(두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때. 즉, 값이 같은지 알고 싶을 때
- equals 메서드 일반 규약
	- 반사성
	- 대칭성
	- 추이성
	- 일관성
	- null-아님
- equals를 재저의할 땐 hashCode도 반드시 재정의
- 너무 복잡하게 해결하려 들지 말자.
- Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.

## 아이템 11 : equals를 재정의하려거든 hashCode도 재정의하라
- equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.
- 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.
- 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다.

## 아이템 12 : toString을 항상 재정의하라
- toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.
- 실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다.
- toString은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 한다.

## 아이템 13 : clone 재정의는 주의해서 진행하라
- Cloneable을 구현하는 것만으로는 외부 객체에서 clone 메서드를 호출할 수 없다.
- Cloneable을 구현한 클래스의 인스턴스에서 clone을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출한다면 CloneNotSupportedException을 던진다.
- Cloneable의 경우에는 상위 클래스에 정의된 protected 메서드의 동작 방식을 변경한 것이다.
- 실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다.
- clone 메서드는 사실상 생성자와 같은 효과를 낸다. 즉, clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야 한다.
- Cloneable 아키텍처는 '가변 객체를 참조하는 필드는 final로 선언하라'는 일반 용법과 충돌한다.
- public인 clone 메서드에서는 throws절을 없애야 한다. 검사 예외를 던지지 않아야 그 메서드를 사용하기 편하기 때문이다.
- Cloneable을 구현한 스레드 안전 클래스를 작성할 때는 clone 메서드 역시 적절히 동기화해줘야 한다.
- Cloneable을 구현한 모든 클래스는 clone을 재정의해야 한다. 이때 접근 제한자는 public으로 반환 타입은 클래스 자신으로 변경.
- 복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 제공할 수 있다.
	- 복사 생성자 : 단순히 자신과 같은 클래스의 인스턴스를 인수로 받는 생성자

## 아이템 14 : 