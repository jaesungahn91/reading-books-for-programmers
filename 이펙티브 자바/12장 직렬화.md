## 아이템 85 : 자바 직렬화의 대안을 찾으라
- 프로그래머가 어렵지 않게 분산 객체를 만들 수 있다는 구호는 매력적이지만, 보이지 않는 생성자, API와 구현 사이의 모호해진 경계, 잠재적인 정확성 문제, 성능, 보안, 유지보수성 등 대가가 큰 문제
- 직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다.
- 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.
- 새로운 시스템에서 자바 직렬화를 써야할 이유는 전혀 없다.
	- 객체와 바이트 시퀀스를 변환해주는 다른 메커니즘이 많이 있다.
	- 크로스-플랫폼 구조화된 데이터 표현
- 간단한 추상화만으로도 아주 강력한 분산 시스템을 구축하기에 충분하고, 자바 직렬화가 가져온 심각한 문제들을 회피할 수 있다.
- 크로스-플랫폼 구조화된 데이터 표현의 선두주자는 JSON과 프로토콜 버퍼다.
- 레거시 시스템 때문에 자바 직렬화를 완전히 배제할 수 없을 때의 차선책은 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이다.
- 직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 객체의 역직렬화 필터링을 사용하자(자바 9에 추가, 이전 버전에도 이식)

## 아이템 86 : Serializable을 구현할지는 신중히 결정하라
- Serializable를 구현하면 릴리스한 뒤에는 수정하기 어렵다.
	- 공개 API가 되므로 계속해서 지원해야 함
- Serializable의 구현이 두 번째 문제는 버그와 보안 구멍이 생길 위험이 높아진다.
	- 역직렬화 = 숨은 생성자
- Serializable 구현의 세 번째 문제는 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.
- Serializable 구현 여부는 가볍게 결정할 사안이 아니다.
- 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 되며, 인터페이스도 대부분 Serializable을 확장해서는 안 된다.
	- 클래스를 확장하거나 인터페이스를 구현하는게 큰 부담
- 내부 클래스는 직렬화 구현하지 말아야 한다.

## 아이템 87 : 커스텀 직렬화 형태를 고려해보라
- 먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라. 기본 직렬화 형태는 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다.
- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.
- 기본 직렬화 형태가 적합하다고 결졍했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.
- 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 네 가지 면에서 문제가 생긴다.
	1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
	2. 너무 많은 공간을 차지할 수 있다.
	3. 시간이 너무 많이 걸릴 수 있다.
	4. 스택 오버플로를 일으킬 수 있다.
- 해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야 한다.
- 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.
- 어떤 직렬화 형태를 택하든 UID를 명시적으로 부여하자.
	- 잠재적인 호환성 문제 사라짐
- 호환성을 끊으려는 경우를 제외하고 UID를 절대 수정하지 말자.

## 아이템 88 : readObject 메서드는 방어적으로 작성하라
- 객체를 역직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 반드시 방어적으로 복사해야 한다.
- readObject에서는 불변 클래스 안의 모든 private 가변 요소를 방어적으로 복사해야 한다.
- 안전한 readObject 메서드 작성 지침
	- 방어적 복사
	- 모든 불변식 검사
	- 역직렬화 후 유효성 검사는 ObjectInputValidation 인터페이스 사용
	- 재정의할 수 있는 메서드는 호출하지 말자.
## 아이템 89 : 인스턴스 수를 통제해야 한다면 readResolve 보다는 열거 타입을 사용하라
- readResolve를 인스턴스 통제 목적으로 사용한다면 객체 참조 타입 인스턴스 필드는 모두 transient로 선언해야 한다.
- 직렬화 가능한 인스턴스 통제 클래스를 열거 타입을 이용해 구현하면 선언한 상수 외의 다른 객체는 존재하지 않음을 자바가 보장
- readResolve 메서드의 접근성은 매우 중요하다. final 클래스에서라면 readResolve 메서드는 private이어야 한다.
## 아이템 90 : 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라
- 직렬화 프록시 패턴은 바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 설계해 private static으로 선언하는 것
- 중첩 클래스의 생성자는 단 하나여야 하며, 바깥 클래스를 매개변수로 받아야 한다.
- writeReplace 메서드 추가
- 바깥 클래스와 논리적으로 동일한 인스턴스를 반환하는 readResolve 메서드를 SerializationProxy 클래스에 추가
- 한계 두 가지
	- 클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없다.
	- 객체 그래프에 순환이 있는 클래스에도 적용할 수 없다.