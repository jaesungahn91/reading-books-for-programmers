## 아이템 85 : 자바 직렬화의 대안을 찾으라
- 프로그래머가 어렵지 않게 분산 객체를 만들 수 있다는 구호는 매력적이지만, 보이지 않는 생성자, API와 구현 사이의 모호해진 경계, 잠재적인 정확성 문제, 성능, 보안, 유지보수성 등 대가가 큰 문제
- 직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다.
- 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.
- 새로운 시스템에서 자바 직렬화를 써야할 이유는 전혀 없다.
	- 객체와 바이트 시퀀스를 변환해주는 다른 메커니즘이 많이 있다.
	- 크로스-플랫폼 구조화된 데이터 표현
- 간단한 추상화만으로도 아주 강력한 분산 시스템을 구축하기에 충분하고, 자바 직렬화가 가져온 심각한 문제들을 회피할 수 있다.
- 크로스-플랫폼 구조화된 데이터 표현의 선두주자는 JSON과 프로토콜 버퍼다.
- 레거시 시스템 때문에 자바 직렬화를 완전히 배제할 수 없을 때의 차선책은 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이다.
- 직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 객체의 역직렬화 필터링을 사용하자(자바 9에 추가, 이전 버전에도 이식)

## 아이템 86 : Serializable을 구현할지는 신중히 결정하라
- Serializable를 구현하면 릴리스한 뒤에는 수정하기 어렵다.
	- 공개 API가 되므로 계속해서 지원해야 함
- Serializable의 구현이 두 번째 문제는 버그와 보안 구멍이 생길 위험이 높아진다.
	- 역직렬화 = 숨은 생성자
- Serializable 구현의 세 번째 문제는 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.
- Serializable 구현 여부는 가볍게 결정할 사안이 아니다.
- 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 되며, 인터페이스도 대부분 Serializable을 확장해서는 안 된다.
	- 클래스를 확장하거나 인터페이스를 구현하는게 큰 부담
- 내부 클래스는 직렬화 구현하지 말아야 한다.

## 아이템 87 : 커스텀 직렬화 형태를 고려해보라
- 먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라. 기본 직렬화 형태는 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다.
- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.
- 기본 직렬화 형태가 적합하다고 결졍했더라도 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때가 많다.
- 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 네 가지 면에서 문제가 생긴다.
	1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.
	2. 너무 많은 공간을 차지할 수 있다.
	3. 시간이 너무 많이 걸릴 수 있다.
	4. 스택 오버플로를 일으킬 수 있다.
- 해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야 한다.
- 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다.
- 어떤 직렬화 형태를 택하든 UID를 명시적으로 부여하자.
	- 잠재적인 호환성 문제 사라짐
- 호환성을 끊으려는 경우를 제외하고 UID를 절대 수정하지 말자.