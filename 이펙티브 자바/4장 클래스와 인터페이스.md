## 아이템 15 : 클래스와 멤버의 접근 권한을 최소화하라
- 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다.
- 구현과 API를 깔끔히 분리한다.
- 정보 은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.
- 정보 은닉의 장점
	- 시스템 개발 속도를 높인다.
	- 시스템 관리 비용을 낮춘다.
	- 소프트웨어 재사용성을 높인다.
	- 큰 시스템을 제작하는 난이도를 낮춰준다.
- 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심이다.
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다가 기본 원칙이다.
- 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
- public 가번 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
- 추상 개념을 완성하는 데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋다.
- 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.

## 아이템 16 : public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
- package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.
- public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다. 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.

## 아이템 17 : 변경 가능성을 최소화하라
- 불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스다.
- 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.
- 클래스를 불변으로 만드는 다섯 가지 규칙
	- 객체의 상태를 변경하는 메서드를 제공하지 않는다.
	- 클래스를 확장할 수 없도록 한다.
	- 모든 필드를 final로 선언한다.
	- 모든 필드르를 private으로 선언한다.
	- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
		- 방어적 복사를 수행
- 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 함수형 프로그래밍이라 한다.
- 불변 객체는 단순한다. 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다.
- 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.
- 불변 객체는 안심하고 공유할 수 있다.
- 불변 클래스는 clone 메서드나 복사 생성자를 제공하지 않는 게 좋다.
- 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다. 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문이다.
- 불변 객체는 그 자체로 실패 원자성을 제공한다.
- 불변 클래스에도 단점은 있다. 값이 다르면 반드시 독립된 객체로 만들어야 한다.
- 상속하지 못하게 하는 유연한 방법은 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 방법이다.
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
- 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.

## 아이템 18 : 상속보다는 컴포지션을 사용하라
- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
- 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션이라 한다.
- 컴포지션과 전달의 조합은 넓은 의미로 위임이라고 부른다. 단, 엄밀히 따지면 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 위이엠 해당한다.
- 래퍼 클래스가 콜배 프레임워크와는 어울리는 점만 주의
- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. 다르게 말하면, 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다.
- 컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴이다.

## 아이템 19 : 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
- API 문서의 메서드 설명 끝에서 종종 "implementation Requirements"로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다.
- 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 기능 메서드를 호출해서는 안 된다.
- 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당함을 알았다.
- 문제를 해결하는 가장 좋은 방법은 상속오용으로 설계하지 않은 클래스는 상속을 금지하는 것

## 아이템 20 : 추상 클래스보다는 인터페이스를 우선하라
- 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다.
- 인터페이스는 믹스인 정의에 안성맞춤이다. 믹스인이란 클래스가 구현할 수 있는 타입. 대상 타입의 주된 기능에 선택적 기능을 '혼합'한다고 해서 믹스인이라 부른다.
- 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.
- 래퍼 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.
- 인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공해 프로그래머들의 일감을 덜어줄 수 있다.
- 인터페이스와 추상 골격 구현 클래스를 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취하는 방법을 템플릿 메서드 패턴이라 한다.
- 골격 구현 클래스의 아름다움은 추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약에서는 자유롭다는 점이다.

## 아이템 21 : 인터페이스는 구현하는 쪽을 생각해 설계하라
- 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다.
- 디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.
- 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.
- 디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아님을 명심.
- 디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계 할 때는 여전히 세심한 주의를 기울여야 한다.

## 아이템 22 : 인터페이스는 타입을 정의하는 용도로만 사용하라
- 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것
- 상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다.
- 상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위다.
- 특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야 한다.
- 또는 인스턴스화할 수 없는 유틸리티 클래스에 담아 공개

## 아이템 23 : 태그 달린 클래스보다는 클래스 계층구조를 활용하라
- 태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적
- 태그 달린 클래스는 클래스 계층구조를 어설프게 흉내낸 아류일 뿐이다.
- 기존 클래스가 태그 필드를 사용하고 있다면 계층구조로 리팩터링하는 것을 고민

## 아이템 24 : 멤버 클래스는 되도록 static으로 만들라
- 중첩 클래스란 다른 클래스 안에 정의된 클래스를 말한다.
- 중첩 클래스의 종류는 정적 멤버 클래스, 멤버 클래스, 익명 클래스, 지역 클래스가 있다.
- 정적 멤버 클래스를 제외한 나머지는 내부 클래스에 해당한다.
- 비정적 멤버 클래스는 메모리 공간을 더 차지마혀, 생성 시간도 더 걸린다.
- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자.