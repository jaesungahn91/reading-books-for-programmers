## 아이템 15 : 클래스와 멤버의 접근 권한을 최소화하라
- 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다.
- 구현과 API를 깔끔히 분리한다.
- 정보 은닉, 혹은 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.
- 정보 은닉의 장점
	- 시스템 개발 속도를 높인다.
	- 시스템 관리 비용을 낮춘다.
	- 소프트웨어 재사용성을 높인다.
	- 큰 시스템을 제작하는 난이도를 낮춰준다.
- 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심이다.
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다가 기본 원칙이다.
- 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
- public 가번 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
- 추상 개념을 완성하는 데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋다.
- 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.

## 아이템 16 : public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
- package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.
- public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다. 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.

## 아이템 17 : 변경 가능성을 최소화하라
- 불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스다.
- 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.
- 클래스를 불변으로 만드는 다섯 가지 규칙
	- 객체의 상태를 변경하는 메서드를 제공하지 않는다.
	- 클래스를 확장할 수 없도록 한다.
	- 모든 필드를 final로 선언한다.
	- 모든 필드르를 private으로 선언한다.
	- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
		- 방어적 복사를 수행
- 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로인 프로그래밍 패턴을 함수형 프로그래밍이라 한다.
- 불변 객체는 단순한다. 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다.
- 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.
- 불변 객체는 안심하고 공유할 수 있다.
- 불변 클래스는 clone 메서드나 복사 생성자를 제공하지 않는 게 좋다.
- 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다. 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문이다.
- 불변 객체는 그 자체로 실패 원자성을 제공한다.
- 불변 클래스에도 단점은 있다. 값이 다르면 반드시 독립된 객체로 만들어야 한다.
- 상속하지 못하게 하는 유연한 방법은 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 방법이다.
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
- 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.

## 아이템 18 : 상속보다는 컴포지션을 사용하라
- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
- 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이러한 설계를 컴포지션이라 한다.
- 컴포지션과 전달의 조합은 넓은 의미로 위임이라고 부른다. 단, 엄밀히 따지면 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우만 위이엠 해당한다.
- 래퍼 클래스가 콜배 프레임워크와는 어울리는 점만 주의
- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰여야 한다. 다르게 말하면, 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다.
- 컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴이다.

## 아이템 19 : 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
- API 문서의 메서드 설명 끝에서 종종 "implementation Requirements"로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다.
- 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.
- 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 기능 메서드를 호출해서는 안 된다.
- 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당함을 알았다.
- 문제를 해결하는 가장 좋은 방법은 상속오용으로 설계하지 않은 클래스는 상속을 금지하는 것