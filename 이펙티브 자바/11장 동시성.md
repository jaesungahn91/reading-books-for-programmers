## 아이템 78 : 
-   

## 아이템 79 : 과도한 동기화는 피하라
- 과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.
- 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.
- 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.
- 가변 클래스를 작성하려거든 다음 두 선택지 중 하나를 따르자.
	- 첫 번째, 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자.
	- 두 번째, 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자
	- 선택하기 어렵다면 동기화하지 말고, "대신 문서에 스레드 안전하지 않다"고 명기

## 아이템 80 : 스레드보다는 실행자, 태스크, 스트림을 애용하라
- `java.util.concureent` 패키지가 등장. 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 포함.
- 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리.
- 작업 단위를 나타내는 핵심 추상 개념이 태스크.
- 태스크에는 Runnable과 Callable 두 가지가 있다.
- 태스크를 수행하는 일반적인 메커니즘이 바로 실행자 서비스

## 아이템 81 : wait와 notify보다는 동시성 유틸리티를 애용하라.
- wait와 notifiy는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.
- 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.
- ConcurrentHashMap은 동시성이 뛰어나며 속도도 무척 빠르다.
- Collections.syschronizedMap 보다는 ConcurrentHashMap을 사용하는 게 훨씬 좋다.
- 동기화 장치는 스레드가 다른 스레드를 기다릴 수 있게 하여, 서로 작업을 조율할 수 있게 해준다. 가장 자주 쓰이는 동기화 장치는 CountDownLatch와 Semaphore.
- 시간 간격을 잴 때는 항상 System.currentTimeMillis가 아닌 System.nanoTime을 사용.
- wait 메서드를 사용할 때는 반드시 대기 반복문 관용구를 사용하라. 반복문 밖에서는 절대로 호출하지 말자.

## 아이템 82 : 스레드 안전성 수준을 문서화하라
- 메서드 선언에 synchronized 한정자를 선언할지는 구현 이슈일 뿐 API에 속하지 않는다. 따라서 이것만으로는 그 메서드가 스레드 안전하다고 믿기 어렵다.
- 멀티스레드 환경에서도 API를 안전하게 사용하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 한다.
- 안전성 높은순 정렬
	- 불변
		- String, Long, BigInteger
	- 무조건적 스레드 안전
		- AtomicLong, ConcurrentHashMap
	- 조건부 스레드 안전
		- Collections.synchronized 래퍼 메서드가 반환한 컬렉션
	- 스레드 안전하지 않음
		- ArrayList, HashMap
	- 스레드 적대적
- 무조건적 스레드 안전 클래스를 작성할 때는 synchronized 메서드가 아닌 비공개 락 객체를 사용하자.

## 아이템 83 : 지연 초기화는 신중히 사용하라
- 지연 초기화는 주로 최적화 용도로 쓰이지만, 클래스와 인스턴스 초기화 때 발생하는 위험한 순환 문제를 해결하는 효과도 있다.
- 해당 클래스의 인스턴스 중 그 필드를 사용하는 인스턴스의 비율이 낮은 반면, 그 필드를 초기화하는 비용이 크다면 지연 초기화가 제 역할을 해줄 것
- 지연 초기화하는 필드를 둘 이상의 스레드가 공유한다면 어떤 형태로든 반드시 동기화해야 한다.
- 대부분의 상황에서 일반적인 초기화가 지연 초기화보다 낫다.
- 성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 관용구를 사용하자.
- 성능 ㄴ때문에 인스턴스 필드를 지연 초기화해야 한다면 이중검사 관용구를 사용하라.

## 아이템 84 : 프로그램의 동작을 스레드 스케줄러에 기대지 마라
- 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.
- 스레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안 된다.
- 스레드는 절대 바쁜 대기 상태가 되면 안 된다.
- Thread.yield를 써서 문제를 고쳐보려는 유혹을 떨처내자. 테스트할 수단도 없다.