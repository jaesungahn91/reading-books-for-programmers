## 아이템 78 : 
-   

## 아이템 79 : 과도한 동기화는 피하라
- 과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 한다.
- 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.
- 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.
- 가변 클래스를 작성하려거든 다음 두 선택지 중 하나를 따르자.
	- 첫 번째, 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자.
	- 두 번째, 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자
	- 선택하기 어렵다면 동기화하지 말고, "대신 문서에 스레드 안전하지 않다"고 명기

## 아이템 80 : 스레드보다는 실행자, 태스크, 스트림을 애용하라
- `java.util.concureent` 패키지가 등장. 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 포함.
- 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리.
- 작업 단위를 나타내는 핵심 추상 개념이 태스크.
- 태스크에는 Runnable과 Callable 두 가지가 있다.
- 태스크를 수행하는 일반적인 메커니즘이 바로 실행자 서비스

## 아이템 81 : wait와 notify보다는 동시성 유틸리티를 애용하라.
- wait와 notifiy는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.
- 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.
- ConcurrentHashMap은 동시성이 뛰어나며 속도도 무척 빠르다.
- Collections.syschronizedMap 보다는 ConcurrentHashMap을 사용하는 게 훨씬 좋다.
- 동기화 장치는 스레드가 다른 스레드를 기다릴 수 있게 하여, 서로 작업을 조율할 수 있게 해준다. 가장 자주 쓰이는 동기화 장치는 CountDownLatch와 Semaphore.
- 시간 간격을 잴 때는 항상 System.currentTimeMillis가 아닌 System.nanoTime을 사용.
- wait 메서드를 사용할 때는 반드시 대기 반복문 관용구를 사용하라. 반복문 밖에서는 절대로 호출하지 말자.