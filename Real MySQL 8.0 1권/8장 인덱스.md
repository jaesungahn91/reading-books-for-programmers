## 8.1 디스크 읽기 방식
- 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건
- 순차 I/O에서는 SSD가 조금 빠르거나 비슷한 성능이지만, 랜덤 I/O는 훨씬 빠르다.(플래터를 돌려서 읽기 때문)
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정
- 때문에 그룹 커밋이나 바이너리 로그 버퍼 또는 로그 버퍼 등의 기능이 내장

## 8.2 인덱스란?
- 책의 맨 끝에 있는 찾아보기(또는 "색인")
- 칼럼의 값을 주어진 순서로 미리 정렬해서 보관
- 데이터 파일은 저장된 순서대로 별도의 정렬 없이 그대로 저장
- INSERT, UPDATE, DELETE 느림 / SELECT 빠름
- 프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류
- 분류에는 B-Tree, Hash, Fractal-Tree, Merge-Tree 등이 있다.
	- B-Tree : 가장 일반적으로 사용. 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
	- Hash : 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘

## 8.3 B-Tree 인덱스
- B-Tree의 "B"는 Balanced를 의미
- 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지
- 루트 노드 - 브랜치 노드 - 리프 노드(주소 값)
- InnoDB에서는 디폴트로 클러스터링 테이블이 생성
- InnoDB 스토리지 엔진에;서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 비트리를 다시 한번 검색해야 한다.
- 비트리는 리프 노드가 분리되는 스플릿을 하기 때문에 상대적으로 쓰기 작업에 비용이 많이 든다.
- 비트리 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부부만 일치하는 경우에 사용할 수 있다.
- 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 주의
- 인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다.
- 인덱스를 이용한 읽기의 손익 분기점
	- 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 비용이 더 든다.
	- 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 필터링 방식으로 처리하는 것이 효율적
- 인덱스를 이용하는 대표적인 방법 세 가지
	- 인덱스 레인지 스캔 : 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
	- 인덱스 풀 스캔 : 인덱스의 처음부터 끝까지 모두 읽는 방식
	- 루스 인덱스 스캔 : 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것
	- 인덱스 스킵 스캔
	- 다중 컬럼 익덱스 : 두 개 이상의 칼럼으로 구성된 인덱스
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 = 커버링 인덱스
- MySQL 8.0 버전 부터는 정렬 순서를 혼합한 인덱스도 생성 가능
- 쿼리가 인덱스를 사용하는 시점에 인덱스를 익는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.
- 오더 바이나 민, 맥스 함수 등의 최적화가 필요한 경우도 인덱스의 읽기 방향을 전환해서 사용
- 쿼리가 많은 레코드를 조호회하면서 빈번하게 실행된다면 오름차순 인덱스보다는 내림차순 인덱스가 더 효율적
- InnoDB에서는 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느리다
	- 페이지 잠금
	- 인덱스 레코드가 단방향으로만 연결
- 비트리 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다

## 8.4 R-Tree 인덱스
- 공간 인덱스는 알트리 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스
- 알트리 인덱스는 2차원의 공간 개념 값이 있다.
- 마이시퀄의 공간 확장
	- 공간 데이터를 저장할 수 있는 데이터 타입
	- 공간 데이터의 검색을 위한 공간 인덱스
	- 공간 데이터의 연산 함수
- MBR이란 해당 도형을 감싸는 최소 크기의 사각형
- ST_Contains() or ST-Within() 등과 같은 포함 관계를 비교하는 함수 사용

## 8.5 전문 검색 인덱스
- 비트리 인덱스는 3072바이트까지만 잘라서 인덱스 키로 사용(InnoDB)
- 문서 전체에 대한 분석과 검색을 위한 이러한 인덱싱 알고리즘을 전문 검색 인덱스라고 한다.
- 전문 검색 인덱스는 문서의 키워드를 인덱싱하는 기법에 따라 크게 단어의 어근 분석과 n-gram 분석 알고리즘으로 구분할 수 있다.
- 어근 분석 알고리즘
	- 불용어 처리, 어근 분석 과정을 거쳐서 색인 작업을 수행
	- 불용어 처리는 검색에서 별 가치 없는 단어를 모두 필터링해서 제거하는 작업
	- 어근 분석은 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업
- n-gram 알고리즘
	- 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘
	- 본문을 무조건 몇 글자식 짤라서 인덱싱
	- n은 인덱싱할 키워드의 최소 글자 수
	- 토큰으로 분리 후 불용어를 걸러내는 작업 수행
- 전문 검색 인덱스를 사용하기 위한 두 가지 조건
	- 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGAINST)을 사용
	- 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

## 8.6 함수 기반 인덱스
- 8.0 부터 함수 기반 인덱스 지원
- 가상 칼럼을 이용한 인덱스
	- VIRTUAL, STORED 사용, 새로운 컬럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다는 단점이 있다.
- 함수를 이용한 인덱스
	- 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 함

## 8.7 멀티 밸류 인덱스
- 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스
- JSON 데이터 타입의 원소들에 대한 인덱스 요건
- MEMBER OF(), JSON_CONTAINS(), JSON_OVERLAPS() 함수들 사용

## 8.8 클러스터링 인덱스
- 테이블의 레코드를 비슷한 것(프라이머리 키 기준)들끼리 묶어서 저장하는 형태로 구현
- InnoDB 스토리지 엔진에서만 지원
- 프라이머리 키 기반의 검색이 매우 빠르다.
- 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리
- 클러스터링 인덱스의 장점은 빠른 읽기, 단점은 느린 쓰기

## 8.9 유니크 인덱스
- 마이시퀄에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.
- 세컨더리 인덱스와 성능상 영향이 거의 없다.
	- 중복체크 때문에 쓰기가 더 느리다.
	- 데드락이 빈번히 발생
- 유일성이 꼭 보장돼야 하는 컬럼에 대해서는 유키느 인덱스를 생성한되, 이외에는 사용을 고려하자.

## 8.10 외래키
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스까지 생성된다.
- 관리 특징
	- 테이블의 변경이 발생하는 경우에만 잠금 경합이 발생
	- 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합을 발생시키지 않는다.