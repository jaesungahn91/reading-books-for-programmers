- 모의 객체를 사용하면 가능한 한 가장 세밀한 수준에서 테스트를 실행할 수 있다.
## 8.1 모의 객체란 무엇인가
- 모의 객체는 테스트 대상인 메서드가 사용하는 객체를 대체하므로, 테스트 대상 메서드는 다른 객체와 격리되는 효과가 생긴다.
- 모의 객체에서 사전에 정의된 동작은 없으면 대신 테스트를 실행하는 중에 모의 객체가 수행할 행동을 기대할 수 있다.
- 모의 객체 초기화 -> 기대 설정 -> 테스트 실행 -> 단언문 검증

## 8.2 모의 객체를 활용해 단위 테스트하기
- 모의 객체는 비즈니스 로직을 가져서는 안 된다.
- 모의 객체를 활용할 때는 테스트가 모의 객체를 이용하기 전에 기대를 정의한다는 특징

## 8.3 모의 객체를 활용해 리팩터링하기
- 훌륭한 설계 전략은 클래스 안에서 객체를 직접 생성하는 것이 아니라 비즈니스로직과 직접 관계없는 객체를 파라미터로 전달하는 것. 궁극적으로 로거나 구성 관련 컴포넌트는 여러 곳에서 사용할 수 있도록 최상위 수준으로 올라가야 한다.

### 8.3.2 리팩터링 시 고려 사항
- 제어의 역전을 적용하는 것은 클래스가 직접 책임지지 않는 객체를 내부에서 생성하는 것이 아니라 외부에서 의존성을 통해 주입하는 것을 의미한다.
- 제어의 역전을 잘 활용하면 단위 테스트를 쉽게 작성할 수 있다.
- 단위 테스트 작성의 핵심은 유연성이다. 테스트를 먼저 작성해야 나중에 코드를 유연하게 만들기 위해 리팩터링하는 데 비용이 많이 들지 않는다.

## 8.4 HTTP 연결 모의하기
- 모의 객체를 사용할 때 의존성 주입을 활용하지 않는다면 실제 클래스를 모의 객체로 바꾸기 어려울 수 있다.
- 코드를 유연하게 작성하도록 주의를 환기하는 것이야말로 모의 객체를 사용해야 하는 가장 큰 이유 중 하나다.

### 8.4.3 첫 번째 시도: 쉬운 리팩터링 기법
- 메서드 팩터리라는 일반적인 리팩터링 방식은 모의할 클래스에 인터페이스가 없을 때 특히 유용하다. 메서드 팩터리 기법은 먼저 대상 클래스를 상속하고, 이를 제어하기 위한 세터 메서드를 추가한다. 그리고 테스트를 위해 원하는 내용을 반환하기 위한 게터 메서드를 재정의한다.
- 메서드 팩터리 괜찮은 기법이지만 완벽하지는 않다.

## 8.5 모의 객체를 트로이 목마로 사용하기
- 모의 객체는 트로이 목마적 속성을 갖고 있지만 그렇다고 악의적인 것은 아니다.
- 모의 객체는 모의 객체를 호출하는 클래스가 인식하지 못하는 상태에서 실제 객체를 대체한다.
- 테스트가 끝날 때 verify 메서드를 사용하여 호출했어야 하는 모든 메서드가 호출됐는지를 검증할 수 있다.
- 일반적으로 기대는 테스트 중에 모의 객체가 우리가 원하는 방식으로 행동하는지 검증하는 것과 동시에 모의 객체를 사용한 내역에 대해 피드백을 받고자 할 때 유용하다.

## 8.6 모의 객체 프레임워크 사용해 보기
- EasyMock, JMock, Mockito

### 8.6.1 EasyMock
- EasyMock 프레임워크는 인터페이스만 모의할 수 있다.
- 클래스를 모의하기 우해서 EasyMock의 클래스 확장을 사용한다.
- EasyMock의 클래스 확장을 사용하여 클래스나 인터페이스에 대한 모의 객체를 생성할 수 있다.

### 8.6.2 JMock
- EasyMock과 달리 JMock은 정적으로 가져올 필요가 없다.

### 8.6.3 Mockito
- 현재 가장 인기 있는 모의 객체 프레임워크
- @Mock 애노테이션 사용
- when 메서드 사용하여 기대 동작
