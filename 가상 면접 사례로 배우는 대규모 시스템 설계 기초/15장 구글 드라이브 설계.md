## 1단계 문제 이해 및 설계 범위 확정
### 개략적 추정치
- 가입 사용자 오천만명, 천만 명의 DAU
- 모든 사용자 10GB 무료 저장공간 할당
- 평균 2개의 파일 업로드, 파일의 평균 크기 500KB
- 읽기:쓰기 비율 1:1
- 필요한 저장공간 총량 = 500페타바이트
- 업로드 API QPS = 240
- 최대 QPS = QPS x 2 = 480

## 2단계 개략적 설계안 제시 및 동의 구하기
- 서버 한 대로 시작
- 파일 업로드 다운로드 웹 서버
- 메타데이터 데이터베이스
- 파일 저장소 시스템

### API
1. 파일 업로드 API
	- 단순 업로드
	- 이어 올리기
2. 파일 다운로드 API
3. 파일 갱신 히스토리 API
- 모든 API는 사용자 인증을 필요, HTTPS 프로토콜 사용해야 함

### 한 대 서버의 제약 극복
- 데이터를 샤딩하여 어러 서버에 나누어 저장
- 파일 저장소로 아마존 S3 사용
	- 다중화 지원

### 동기화 충돌
- 먼저 처리되는 변경은 성공, 나중에 처리되는 변경은 충동이 발생한 것으로 표시
- 오류가 발생한 시점에 같은 파일의 두 가지 버전이 존재

### 개략적 설계안
- 사용자 단말
- 블록저장소 서버 : 파일 블록을 클라우드 저장소에 업로드하는 서버
- 클라우드 저장소
- 아카이빙 저장소
- 로드밸런서
- API 서버
- 메타데이터 데이터베이스
- 메타데이터 캐시
- 알림 서비스
- 오프라인 사용자 백업 큐

## 3단계 상세 설계
### 블록 저장소 서버
- 정기적으로 갱신되는 큰 파일들은 업데이트가 일어날 때마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 잡어먹게 된다.
- 최적화 방법
	- 델타 동기화 : 수정이 일어난 블록만 동기화
	- 압축 : 블록 단위로 압축

### 높은 일관성 요구사항
- 강한 일관성 모델을 기본으로 지원
- ACID를 기본 지원하는 관계형 데이터베이스를 채택하여 높은 일관성 요구사항에 대응할 것

### 메타데이터 데이터베이스
- 테이블
	- user, device, namespace, file, file_version
### 업로드 절차
- 파일 메타데이터 추가
	1. 새 파일의 메타데이터 추가
	2. 업로드 상태 대기중으로 변경
	3. 새 파일이 추가되었음을 알림
	4. 다른 클라이언트에게 업로드 중을 알림
- 파일을 클라우드 저장소에 업로드
	1. 블록 저장소 서버에 업로드
	2. 블록 단위로 쪼개고 압축하고 암호화
	3. 업로드 종료시 콜백을 호출
	4. 업로드 상태를 완료로 변경
	5. 알림 서비스에 통지

### 다운로드 절차
- 파일을 편집하거나 추가했다는 사실을 어떻게 감지
	1. 접속 중 : 알림서비스를 통해 감지
	2. 비접속 : 캐시에 저장

### 알림 서비스
- 파일의 일관성을 유지하기 위해
- 알림 서비스는 이벤트 데이터를 클라이언트들로 보내는 서비스
	- 롱폴링
	- 웹소켓
- 롱 폴링 사용
	- 알림 서비스와 양방향 통신이 필요하지 않다.

### 저장소 공간 절약
- 파일 갱신 이력을 보존하고 안정성을 보장하기 위해서는 파일의 여러 버전을 여러 데이터센터에 보관할 필요가 있다.
- 중복 제거 : 중복된 파일 블록을 계정 차원에서 제거
- 지능적 백업 전략 : 한도 설정, 중요한 버전만 보관
- 자주 쓰이지 않는 데이터는 아카이빙 저장소로 이동