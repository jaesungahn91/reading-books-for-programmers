## 저장소 시스템 101
- 블록 저장소
- 파일 저장소
- 객체 저장소
## 1단계: 문제 이해 및 설계 범위 확정
### 기능 요구사항
- 버킷 생성
- 객체 업로드 및 다운로드
- 객체 버전
- 버킷 내 객체 목록 출력 기능
### 비기능 요구사항
- 100PB 데이터
- 식스나인 수준의 데이터 내구성
- 포나인 수준의 서비스 가용성
- 저장소 효율성

### 대략적인 규모 추정
- 디스크 용량
	- 20% 1MB 작은 객체
	- 60% 1MB ~ 64MB 중간크기 객체
	- 20% 64MB 이상의 대형 객체
- IOPS : 100 ~ 150 IOPS

## 2단계: 개략적 설계안 제시 및 동의 구하기
### 개략적 설계안
- 로드밸런서
- API 서비스
- 데이터 저장소
- 메타데이터 저장소

### 객체 업로드
1. HTTP PUT - 버킷 생성
2. IAM - 권한 확인
3. 메타데이터 호출
4. 객체 생성 HTTP PUT 요청
5. 권한 소유 여부 확인
6. 데이터 저장소 객체로 저장 - UUID 반환
7. 메타 데이터 저장

### 객체 다운로드
1. 로드밸런서를 통해 요청 확인
2. 리드 권한 확인
3. UUID를 통해 메타데이터 조회
4. UUID를 통해 객체 데이터를 가져옴
5. 객체 데이터 반환

## 3단계: 상세 설계
### 데이터 라우팅 서비스
- 데이터를 저장할 최적의 데이터 노드를 판단
- 데이터를 읽어 API 서비스에 반환
- 데이터 노드에 데이터 기록
### 배치 서비스
- 어느 데이터 노드에 데이터를 저장할지 결정하는 역할을 담당
### 데이터 노드
- 실제 객체 데이터가 보관되는 곳
- 다중화 그룹으로 안정성과 내구성을 보장
### 데이터 내구성
- 다중화 필요
- 장애 도메인은 중요한 서비스에 문제가 발생했을 때 부정적인 영향을 받는 물리적 또는 논리적 구획
- 데이터를 여러 AZ에 복제해 놓으면 장애 여파를 최소화
### 큰 파일의 업로드 성능 최적화
- 큰 객체는 작게 쪼갠 다음 독립적으로 업로드
- 모든 조각이 업로드되고 나면 객체 저장소는 그 조각을 모아서 원본 객체를 복원 = 멀티파트 업로드