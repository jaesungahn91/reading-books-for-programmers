## 1단계: 문제 이해 및 설계 범위 확정
### 기능 요구사항
- 주변 친구 확인 기능
- 친구 목록은 몇 초마다 한번씩 갱신
### 비기능 요구사항
- 낮은 지연 시간
- 안정성
- 결과적 일관성
### 개략적 규모 추정
- '주변 친구'는 8km 반경 이내 친구로 정의
- 친구 위치 정보 30초 주기로 갱신(걷는 속도 고려)
- 평균 매일 사용자 1억명으로 가정
- 동시 접속 사용자 DAU의 10% = 천만명
- 평균적으로 한 사용자는 400명의 친구를 갖는다.
```
QPS 계산
- 1억 DAU
- 동시 접속 사용자  = 1억 * 10% = 천만
- 30초마다 자기 위치 전송
- 천만/30 =~ 334,000
```

## 2단계: 개략적 설계안 제시 및 동의 구하기
### 개략적 설계안
- 새위치 정보를 수신하기 위해 공용 백엔드 사용
	- 위치 변화 내역 수신
	- 모든 활성 상태 친구를 찾아서 변경 내역 전달
	- 특정 임계치 보다 가까울 경우 변경 내역 전송
### 설계안
- 로드밸런서
- RESTful API서버
	- 부가적인 작업(친구 추가/삭제 등)
- 웹소켓 서버
	- 친구 위치 정보 변경을 실시간으로 처리하는 유상태 서버 클러스터
- 레디스 위치 정보 캐시
	- 활성 상태 사용자의 가장 최근 위치 정보를 캐시
- 사용자 데이터베이스
	- 친구 관계 정보 저장
- 위치 이동 이력 데이터베이스
	- 위치 변동 이력 보관
- 레디스 펍/섭 서버
	- 사용자의 위치가 바뀌면 해당 사용자의 모든 친구의 웹소켓 연결 핸들러 호출
- 주기적 위치 갱신
	- 웹소켓 연결을 통해 주기적으로 위치 변경 내역 전송
### 데이터 모델
- 위치 정보 저장에 데이터베이스를 사용하지 않는 이유
	- 사용자의 현재 위치만을 이용하고 위치 정보에 대해서는 영속성을 보장할 필요가 없다.
- 위치 이동 이력 데이터베이스
	- 막대한 쓰기 연산 부하를 감당할 수 있고, 수평적 규모 확장이 가능한 데이터베이스가 필요
## 3단계: 상세 설계
### 중요 구성요소별 규모 확장성
- 웹소켓 서버
	- 규모를 자동으로 늘리는 것은 어렵지 않지만 유상태 서버라 주의 필요
- 레디스 펍/섭 서버
	- 위치 변경 내역 메시지의 라우팅 계층으로 활용
	- 비용이 아주 저렴
	- 소량의 메모리만을 사용
	- 따라서 친구의 상태를 개의치 않는다면. 복잡도를 낮게 개발 가능(상태별 추가 작업이 필요 없음)
- 얼마나 많은 레디스 펍/섭 서버가 필요한가?
	- 레디스 펍/섭 서버의 병목은 메모리가 아니라 CPU 사용량
	- 클러스터 필요
- 분산 레디스 펍/섭 클러스터
	- 채널을 분산할 방법으로 서비스 탐색 컴포넌트를 도입하여 문제 해결
	- 서비스 탐색 컴포넌트로 etcd, 주키퍼 등이 가장 널리 사용
	- 웹소켓 서버는 해시 링을 참조하여 메시지를 발행할 레디스 펍/섭 서버를 선정
- 레디스 펍/섭 서버 클러스터의 규모 확장 고려사항
	- 데이터는 전송되고 나면 바로 삭제 = 무상태
	- 채널에 대한 상태 정보는 = 유상태
	- 클러스터 크기 조정은 생각보다 간단
- 운영 고려사항
	- 새 서버 교체시 교체되는 서버의 채널만 손보면 된다.
	- 새 펍/섭 서버의 채널 다시 구독 필요
### 친구 추가 /삭제
- 친구 추가시 새 친구의 펍/섭 채널 구독 필요
### 친구가 많은 사용자
- 친구 관계 양방향
- 많은 친구를 둔 사용자의 채널이 존재하는 펍/섭 서버의 경우만 조금 더 많은 부하.
### 주변의 임의 사용자
- 지오해시에 따라 구축된 펍/섭 채널 풀을 둔다.
- 해당 격자 내의 모든 사용자는 해당 격자에 할당된 채널을 구독
### 레디스 펍/섭 외의 대안
- 얼랭은 고도로 분산된 병렬 애플리케이션을 위해 고안된 프로그래밍 언어이자 런타임 환경