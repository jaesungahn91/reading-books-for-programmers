## 1단계: 문제 이해 및 설계 범위 확정
### 기능 요구사항
- 순위표 상위 10명의 플레이어 표시
- 특정 사용자의 순위 표시
- 어떤 사용자보다 4순위 위와 아래에 있는 사용자를 표시
### 비기능 요구사항
- 점수 업데이트는 실시간으로 순위표에 반영
- 일반적인 확장성, 가용성 및 안정성 요구사항
### 개략적 규모 추정
- DAU 500만 명 -> 초당 50명의 사용자가 게임 플레이
- 최대 부하는 평균의 다섯배
- 초당 최대 250명의 사용자 감당
- QPS : 50 x 10, 최대 : 2,500
## 2단계: 개략적 설계안 제시 및 동의 구하기
### 개략적 설계안
1. 사용자 게임 승리 -> 게임서비스 요청
2. 게임 서비스는 승리 유효성 확인 후 순위표 서비스에 점수 갱신 요청
3. 순위표 서비스 사용자의 점수 갱신
4. 클라이언트가 상위 10명 순위표, 해당 사용자 순위 요청
- 중간자 공격에서 안전하기 위해 순위표 서비스를 분리
- 게임 서비스에서의 데이터가 순위표 이외에도 사용된다면, 메시지 큐를 도입하는게 좋음

### 데이터 모델
- 수백만 명의 사용자에 대해서도 예측 가능한 성능을 제공하고 복잡한 DB 쿼리없이도 일반적인 순위표 작업을 쉽게 수행하는 방법으로 레디스의 정렬 집합 자료형 사용
- 데이터의 영속성을 위해 레디스는 데이터를 디스크에 영속적으로 보관하는 옵션도 지원
## 3단계: 상세 설계
### 클라우드
- 아마존 API 게이트웨이와 AWS 람다 사용
### 레디스 규모확장
- 데이터 샤딩 방안으로 고정 파티션, 해시 파티션의 방식이 존재
- 고정 파티션
	- 점수의 범위에 따라 파티션을 나누는 방안
	- 점수가 고르게 분포되어야 한다.
- 해시 파티션
	- 레디스 클러스터를 사용하는 것
	- 특정 키를 기준으로 해시 슬롯에 속하도록 하는 샤딩 기법 사용
	- 상위 10명의 플레이어를 검색하는 것은 까다롭다. 해결하기위해 분산-수집 접근법 사용
- 쓰기 작업이 많은 애플레키에션에는 많은 메모리가 필요
### 대안: NoSQL
- 쓰기연산에 최적화
- 같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능

